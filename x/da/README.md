# DA

## Overview

- Offloading erasure coding and KZG commitment to off-chain workers
- Offloading blob delivery from mempool
  - Network bandwidth consumption is reduced to constant order from linear with blob size
- Deterministic shard allocation for each validator
- KZG-commitment based blazing fast data availability
  - Minimum 2 blocks for confirmation
    - One block for `MsgDeclareBlob`
    - One block for `MsgBundleCommitments`

```plaintext
□:2048byte
■:Parity shard
□□..□□: 128KiB

Case1: Blob less than 2048byte
Data will be padded to 2048byte with zeros
□
↓
□■

Case2: Blob more than 2048byte
□□□□
↓
□□□□■■■■

Case3: Blob 128KiB
□□..□□
↓
□□..□□■■..■■

Case3: Blob more than 128KiB
□□..□□□□
↓
Wrapped into 2 rows
□□.□□□
□□.□□□
↓
□□.□□□■■..■■■
□□.□□□■■..■■■
```

## Erasure coding and KZG commitment

Wrapped blob row is converted into elements on scalar field of BLS12-381 $\{y_i\} \in F_r$.

With BLS12-831, the evaluation points $x_i$ is defined as

$$
  x_i = \omega^i
$$

By using Fast Fourier Transform, the polynomial $f(\cdot)$ can be computed as

$$
  y_i = f(x_i)
$$

By preparing extended evaluation points like

$$
  \hat{x}_i = \omega^{n+i}
$$

The polynomial $f(\cdot)$ can be used as

$$
  \hat{y}_i = f(\hat{x}_i)
$$

then $\hat{y}_i$ will be the parity data.

Finally, once the KZG commitment for the polynomial $f(\cdot)$ is computed,
we can verify that the parity data is correctly generated by the polynomical.

Note that KZG commitment is computed per row.

## Flows

- User declares a blob with
  - Metadata URI
  - Shards merkle root
  - KZG commitments merkle root
- Validators invoke the off chain process in the safe location
- Validators download the metadata and download the deterministically corresponding shards
  - Metadata has
    - Shard hashes
    - KZG commitments
    - KZG opening proof for $m$ evaluation points where $m = \log_2{\text{shardCount}}$
- Validators confirm the shards merkle root and KZG commitments merkle root
- Validators post the signed commitment to the webhook of the bundler
- The bundler posts the `MsgBundleCommitments`
- Finally, light clients can validate the Data Availability.

## Challenge

In addition, Sunrise will have a mechanism for incentivizing validators to make the data available.
This is done by preparing a challenge mechanism to request the KZG opening proof for deterministically selected evaluation points.
To create the KZG opening proof, it is needed to know the coefficients of the polynomial $f(\cdot)$.
